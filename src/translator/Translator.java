//===---------------- Translator.java - the driver ------------------------===//
//
//  This is the main driver program which invokes all the other passes: lexer, 
//  parser, transformation passes, and unparser.
//
//===----------------------------------------------------------------------===//
//
//  Developed by Jagan Jayaraj and Pei-Hung Lin
//  Copyright 2007-2013, Regents of the University of Minnesota
//
//  Copyright 2014 Sandia Corporation. Under the terms of Contract
//  DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
//  certain rights in this software.
//
//  This file is part of CFDbuilder.
//
//  CFDbuilder is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  CFDbuilder is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with CFDbuilder.  If not, see <http://www.gnu.org/licenses/>.
//
//  Contacts: {jaganj,phlin}@cs.umn.edu, paul@lcse.umn.edu
//
//===----------------------------------------------------------------------===//


package translator;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import javax.swing.JOptionPane;

import org.antlr.runtime.ANTLRInputStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RuleReturnScope;
import org.antlr.runtime.TokenRewriteStream;
import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.antlr.runtime.tree.DOTTreeGenerator;
//import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.StringTemplateGroup;
import org.antlr.stringtemplate.StringTemplateWriter;
import org.jdesktop.application.Action;

import lexer.*;
import parser.*;
import pipeliner.*;
import symbol.*;
import translator.*;
import inliner.*;
import reduceMem.*;
import equivalencer.*;
/*import unparser.CUnParser;
import unparser.SSEUnParser;
import unparser.FortranAltiVecUnParser;
*/
import unparser.FortranUnParser;

public class Translator {

 public static FTreeAdaptor fTreeAdaptor = new FTreeAdaptor();
   
 static FortranLexer lexer;
 static CommonTokenStream tokens;
 static FortranParser parser;
 static FTree t;
 static SymbolTable symtab = new SymbolTable();
 static FCommonTreeNodeStream nodes;
 static LabelTable lbltab = new LabelTable();
   
 static File inputfile, outputfile;
 static boolean keeptmpfiles = true;
 static boolean gendot = false;
 public enum Op {INVALID, INLINE, EQUIVALENCE, REDUCEMEM, PIPELINE};
 static RuleReturnScope r;
 
 // Names of temporary files generated by CFDbuilder
 static String macroProcessed = "processed-CFDBDR.f";
 static String      outerCode = "outercode-CFDBDR.f";
 static String  computeRegion = "compute-CFDBDR.f";
 
 // Names of output files generated
 static String    inlinedCode = "output_inlined.f";
 static String  pipelinedCode = "output_pipelined.f";
 
 public static void main(String[] args) throws Exception {
   Op op = Op.INVALID;
   // Process the arguments
   if (args.length>0) {
     for (int argidx = 0; argidx < args.length-1; ++argidx) {
       // Switch case on Strings doesn't work on all versions of Java.
       if(args[argidx].equals("-dot"))
         gendot = true;    
       if(args[argidx].equals("-nokeep"))
         keeptmpfiles = false;
       if(args[argidx].equals("-pipeline"))
         op = Op.PIPELINE;
       if(args[argidx].equals("-reduceMem"))
         op = Op.REDUCEMEM;
       if(args[argidx].equals("-equivalence"))
         op = Op.EQUIVALENCE;            
       if(args[argidx].equals("-inline"))
         op = Op.INLINE;
     }
     // The input file is assumed to be the last argument
     inputfile = new File(args[args.length-1]);
   }    
   
   if(inputfile == null){      
     System.out.println("Need an input file");
     System.exit(-1);
   }
   init(inputfile);
   // Call the appropriate group of passes.
   switch(op)
   {
   case PIPELINE:
     pipeline();
     break;
   case REDUCEMEM:
     reduceMem();
     break;
   case EQUIVALENCE:
     equivalence();
     break;
   case INLINE:
     inline();
     break;
   case INVALID:
     System.out.println("No operation has been specified to the translator");
     System.exit(0);
   }
   clean();
 } //end of main
 
 // Have the AST ready for the transformation passes. It performs the following
 // operations: preprocess the Fortran source for lexing, calls the lexer and
 // parser, constructs the symbol table, renames the labels within the region
 // to be transformed to begin at 1, and construct tokens for the PPM directives
 // present in the comment lines.
 public static void init(File inputfile) throws Exception{
   preProcessSourceFile(inputfile.getAbsolutePath());
   
   // The compute region is now in a separate file which we open here.
   File infile = new File(computeRegion);
   FileInputStream fstream = new FileInputStream(infile);
   ANTLRInputStream input = new ANTLRInputStream(fstream);
   
   // Call the lexer and parser
   lexer = new FortranLexer(input);
   tokens = new CommonTokenStream(lexer);       
   parser = new FortranParser(tokens);
   parser.setTreeAdaptor(translator.Translator.fTreeAdaptor);
   r = parser.program();
   t = (FTree)r.getTree();
   fstream.close();       
    
   // Print the AST
   /*if(gendot == true){
      FileOutputStream dotoutput = new FileOutputStream("source_tree.dot");
      PrintStream dotfile = new PrintStream(dotoutput);
      DOTTreeGenerator dot = new DOTTreeGenerator();
      //System.out.println(dot.toDOT(t));
      dotfile.println(dot.toDOT(t));
      System.out.println("tree: "+t.toStringTree());        
   }else{
      PrintWriter outfile = new PrintWriter(new FileWriter("source_tree.txt"));
      outfile.println(t.toStringTree());
      outfile.close();
   }*/
       
   // Create the symbol table
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);
   nodes.setTokenStream(tokens);
   symtab.reset();
   lbltab.reset();
   symtableCreator symcreator = new symtableCreator(nodes,symtab,lbltab);
   symcreator.setTreeAdaptor(Translator.fTreeAdaptor);
   //System.out.println("nodes before "+((FTree)nodes.getTreeSource()).toStringTree());
   symcreator.program();       
   //t = (FTree)r.getTree();
    
   // This following code will rename all labels to start from 1 so it is easier 
   // to generate unique labels in later passes.  The labels need to be unique
   // only within a program unit (ie) subroutine, main program, and such.
   nodes.reset();
   renameLabel rl = new renameLabel(nodes,symtab,lbltab);
   rl.setTreeAdaptor(Translator.fTreeAdaptor);
   t = (FTree)rl.downup(t,true);

   // Convert the PPM directives in the comments into tokens for the benefit of
   // the later passes.
   nodes.reset();  
   TokenizePPMdir fr1 = new TokenizePPMdir(nodes,symtab);
   fr1.setTreeAdaptor(Translator.fTreeAdaptor);
   t = (FTree)fr1.downup(t,false);
   //System.out.println("nodes after "+((FTree)nodes.getTreeSource()).toStringTree());
   nodes.reset();        
   //System.out.println("Output_orig: "+t.toStringTree());
   //System.exit(-1);
   //genFortran(nodes,symtab,"output_orig.f");
   
   /*nodes.reset();
   findName fn = new findName(nodes, symtab);
   fn.setTreeAdaptor(Translator.fTreeAdaptor);
   fn.downup(t);*/
   //mytranslator.printSymbolTable(symtab);

 }

 // Remove the temporary files
 public static void clean() throws Exception{
   if(keeptmpfiles != true){
     if(deletefile(macroProcessed)) System.out.println("Temporary file "+macroProcessed+" was deleted.");
     if(deletefile(outerCode)) System.out.println("Temporary file "+outerCode+" was deleted.");
     if(deletefile(computeRegion))   System.out.println("Temporary file "+computeRegion+" was deleted.");
   }
 }
 
 // Inline subroutines
 @Action
 public static void inline() throws Exception {
   // Create the inliner pass	 
   nodes.reset();
   inliner myinline = new inliner(nodes,symtab,lbltab);
   myinline.setTreeAdaptor(Translator.fTreeAdaptor);
   
   r = myinline.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);  
   
   // Recursively inline all the subroutine calls
   nodes.reset();
   while(myinline.ismodified){
     myinline.ismodified = false;
     myinline.setTreeNodeStream(nodes);
     myinline.setsymtable(symtab);
     r = myinline.program();
     t = (FTree)r.getTree();
     nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
     nodes.setTokenStream(tokens); 
     nodes.reset();
   }
   
   // Debugging output: print the inlined tree
   //System.out.println("Inlined tree: "+t.toStringTree());
   //System.exit(-1);
   /*FileOutputStream dotoutput = new FileOutputStream("source_tree.dot");
   PrintStream dotfile = new PrintStream(dotoutput);
   DOTTreeGenerator dot = new DOTTreeGenerator();
   //System.out.println(dot.toDOT(t));
   dotfile.println(dot.toDOT(t));*/
   
   // Output the inlined code
   genFortran(nodes,symtab,inlinedCode);
       
   // Debugging output: print all the symbols after inlining   
   /*       
   System.out.println("after tree rewrite: globals: "+symtab.globals.toString());
   Set<String> set = symtab.globals.enclosedFunctions.keySet();
   Iterator<String> iter=set.iterator();
   while(iter.hasNext()){
     FunctionSymbol f = symtab.globals.enclosedFunctions.get(iter.next());
     System.out.println("function "+f.name+": "+f.orderedArgs.toString());
     BaseScope b = (BaseScope)f.enclosedScope;
     System.out.println("local: "+b.symbols.toString());
   }
   */
 }  
 
 @Action
 public static void pipeline() throws Exception {
   nodes.reset();   
 
   // We need to eliminate the index offset variables generated for the 
   // redundant loop iterations. The table below stores such variables.
   HashMap redsubExpr = new HashMap(); 
   
   // Eliminate redundant iterations from WB
   pass1_delRedIter fr1 = new pass1_delRedIter(nodes,lbltab,redsubExpr);
   fr1.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr1.program();
   //System.out.println("node tree source before  "+nodes.getTreeSource());
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);
   nodes.setTokenStream(tokens);     

   // Inline
   System.out.println("Inlining before pipelining"); 
   inline();
   nodes.reset();
   
   // The computed results must be written out in briquettes. When the number
   // of boundary cells, nbdy, is not a multiple of briquette size, nsugar, this
   // pass inserts the appropriate number of pipeline stages to store the
   // computed results which can't be written out yet.
   pass2_repack fr2 = new pass2_repack(nodes);
   fr2.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr2.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);
   nodes.setTokenStream(tokens);

   // Simplify constant subscript expressions
   SimplifySubscript fr2to3 = new SimplifySubscript(nodes);
   fr2to3.setTreeAdaptor(Translator.fTreeAdaptor);
   t = (FTree)fr2to3.downup(t,false);
   nodes.reset();        
   //mytranslator.genFortran(nodes,symtab,"output_pipelined_simplified.f");
   //System.out.println("tree: "+t.toStringTree());        
   //nodes.reset();  
   
   // Handles double buffering, prefetching, and de-double buffering.   
   pass3_dblBuffer_modern fr3 = new pass3_dblBuffer_modern(nodes,symtab,lbltab);
   //pass3_dblBuffer fr3 = new pass3_dblBuffer(nodes,lbltab);
   fr3.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr3.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);
     
   // Find the bounds of the loops to be pipelined. This helps with pipelining
   // the individual loops which now become part of one common outer loop.
   PipelinedTmps pipelinedTmps = new PipelinedTmps();     
   pass4_findIterSpace fr4_1 = new pass4_findIterSpace(nodes,symtab,lbltab);
   fr4_1.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr4_1.program();
   //System.out.println("node tree source before  "+nodes.getTreeSource());
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);     
 
   // Convert the individual loops to become part of the common outer loop. 
   // Generate any necessary guard (IF) statements to prevent the loop body from 
   // being executed when we prime the pump i.e. the first few iterations of the
   // pipeline loop.
   pass4_ldLoop2if fr4 = new pass4_ldLoop2if(nodes,symtab,lbltab);
   fr4.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr4.program();
   //System.out.println("node tree source before  "+nodes.getTreeSource());
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);
 
   // Figure out the size of storage necessary for each temporary
   reduceMem1 fr5_1 = new reduceMem1(nodes,lbltab,pipelinedTmps,false);
   fr5_1.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr5_1.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);        
   nodes.reset();
   
   // Convert the temporaries into circular buffers with the minimum
   // number of planes for each temporary.
   reduceMem2 fr5_2 = new reduceMem2(nodes,pipelinedTmps,false);
   fr5_2.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr5_2.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);        
   nodes.reset();
   //System.out.println("pass5_reduceMem tree: "+t.toStringTree());
   //mytranslator.genFortran(nodes,symtab,"output_pipelined4pbp.f");
   
   // This is the last of a very tightly coupled set of passes. It ties up
   // all the loose ends created by the previous passes.  This pass along with
   // all the above passes in this procedure must not be uncoupled. The AST
   // is in an inconsistent state until it reaches the end of this pass.
   //
   // Generates the common outer loop, sets up the indexes for the circular 
   // buffers, and initializes various other temporaries involved in pipelining.
   //nodes.reset();     
   pass6_loopOverPlanes fr6 = new pass6_loopOverPlanes(nodes,lbltab);
   fr6.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr6.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);       
   nodes.reset();     
     
   // Simplify the subscripts again
   SimplifySubscript fr7 = new SimplifySubscript(nodes);
   fr7.setTreeAdaptor(Translator.fTreeAdaptor);
   t = (FTree)fr7.downup(t,false);
   nodes.reset();     
   
   // Equivalence all the automatic arrays in the computational region to one
   // big array. This allows us to somewhat control the virtual addresses of 
   // the temporaries. We arrange them in the order of use hoping that the 
   // subsequent temporaries will be assigned to different sets, and thereby 
   // avoid set conflicts in L1D cache.
   equivalencer fr8 = new equivalencer(nodes);
   fr8.setTreeAdaptor(Translator.fTreeAdaptor);
   r = fr8.program();
   t = (FTree)r.getTree();
   nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
   nodes.setTokenStream(tokens);
   
   // Generate the pipelined output
   genFortran(nodes,symtab,pipelinedCode);
   //System.out.println("tree: "+t.toStringTree());        
   nodes.reset();
 }
 
 @Action
 public static void reduceMem() throws Exception {
     nodes.reset();   
     
     System.out.println("Inlining before the second phase of pipelining");
     inline();
     nodes.reset();    
                  
     PipelinedTmps pipelinedTmps = new PipelinedTmps();
     reduceMem1 fr1 = new reduceMem1(nodes,lbltab,pipelinedTmps,true);
     fr1.setTreeAdaptor(Translator.fTreeAdaptor);
     r = fr1.program();
   //System.out.println("node tree source before  "+nodes.getTreeSource());
     t = (FTree)r.getTree();
     nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
     nodes.setTokenStream(tokens);
//         System.out.println("tree: "+t.toStringTree());
 /*        gendot = true;
       if(gendot == true){
           FileOutputStream dotoutput = new FileOutputStream("source_tree.dot");
           PrintStream dotfile = new PrintStream(dotoutput);
           DOTTreeGenerator dot = new DOTTreeGenerator();
           //System.out.println(dot.toDOT(t));
           dotfile.println(dot.toDOT(t));
           //System.out.println("tree: "+t.toStringTree());        
        }else{
           PrintWriter outfile = new PrintWriter(new FileWriter("source_tree.txt"));
           outfile.println(t.toStringTree());
           outfile.close();
        }
 */

     reduceMem2 fr2 = new reduceMem2(nodes,pipelinedTmps,true);
     fr2.setTreeAdaptor(Translator.fTreeAdaptor);
     r = fr2.program();
     t = (FTree)r.getTree();
     nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
     nodes.setTokenStream(tokens);        
     nodes.reset();        
   //System.out.println("pass5_reduceMem tree: "+t.toStringTree());

/*     reduceMem3SW fr2 = new reduceMem3SW(nodes,pipelinedTmps,true);
     fr2.setTreeAdaptor(Translator.fTreeAdaptor);
     r = fr2.program();
     t = (FTree)r.getTree();
     nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
     nodes.setTokenStream(tokens);        
     nodes.reset();        
   //System.out.println("pass5_reduceMem tree: "+t.toStringTree());
*/     
     SimplifySubscript fr3 = new SimplifySubscript(nodes);
     fr3.setTreeAdaptor(Translator.fTreeAdaptor);
     t = (FTree)fr3.downup(t,false);
     nodes.reset();
     genFortran(nodes,symtab,"output_memReduced.f");
    //System.out.println("tree: "+t.toStringTree());        
     nodes.reset();
//     nodes.setTokenStream(tokens);
 }

 public static void equivalence() throws Exception {
        nodes.reset();   

         inline();
         nodes.reset();                     
        
        equivalencer fr1 = new equivalencer(nodes);
        fr1.setTreeAdaptor(Translator.fTreeAdaptor);
        r = fr1.program();
      //System.out.println("node tree source before  "+nodes.getTreeSource());
        t = (FTree)r.getTree();
        nodes = new FCommonTreeNodeStream(Translator.fTreeAdaptor,t);        
        nodes.setTokenStream(tokens);
//            System.out.println("tree: "+t.toStringTree());
    /*        gendot = true;
          if(gendot == true){
              FileOutputStream dotoutput = new FileOutputStream("source_tree.dot");
              PrintStream dotfile = new PrintStream(dotoutput);
              DOTTreeGenerator dot = new DOTTreeGenerator();
              //System.out.println(dot.toDOT(t));
              dotfile.println(dot.toDOT(t));
              //System.out.println("tree: "+t.toStringTree());        
           }else{
              PrintWriter outfile = new PrintWriter(new FileWriter("source_tree.txt"));
              outfile.println(t.toStringTree());
              outfile.close();
           }
    */
        nodes.reset();
        genFortran(nodes,symtab,"output_equivalenced.f");
    }
 
public void printSymbolTable(SymbolTable symtab){
   /* This section can print out all the symbols in the symbol table */
    System.out.println("globals: "+symtab.globals.toString());
    Set<String> set = symtab.globals.enclosedFunctions.keySet();
    Iterator<String> iter=set.iterator();
    while(iter.hasNext()){
       FunctionSymbol f = symtab.globals.enclosedFunctions.get(iter.next());
        System.out.println("function "+f.name+": "+f.orderedArgs.toString());
        BaseScope b = (BaseScope)f.enclosedScope;
        System.out.println("local: "+b.symbols.toString());
      }
}
/*
 * 
PHLIN: genFortran file will use FotranUnParser to create the Fortran output file.
 *
 */
public static void genFortran(FCommonTreeNodeStream nodes,SymbolTable symtab, String outputname) throws Exception{   
   ClassLoader cl = Translator.class.getClassLoader();
   InputStream is = cl.getResourceAsStream("StringTemplate/f77.stg");
   InputStreamReader isr = new InputStreamReader(is);
    BufferedReader groupFileR = new BufferedReader(isr);
    //String templateFile = "StringTemplate/f77.stg";
   //FileReader groupFileR = new FileReader("src/StringTemplate/f77.stg");
   StringTemplateGroup templates = new StringTemplateGroup(groupFileR);
   groupFileR.close();      
   
    FortranUnParser unparser = new FortranUnParser(nodes,symtab);
    unparser.setTemplateLib(templates); 
    RuleReturnScope unparser_result = unparser.program();
    StringTemplate output = (StringTemplate)unparser_result.getTemplate();
    StringWriter out = new StringWriter();
    StringTemplateWriter templateWriter = new ModAutoIndentWriter(out);
    output.write(templateWriter);
    if (null == out.toString())       
   {
      System.err.println("output is null! No Fortran output file is created!!");
      return;
   }
    
    //System.out.println(output.toString());
   PrintWriter outfile = new PrintWriter(new FileWriter(outputname));
    BufferedReader inputStream = null;
   try{
      String line;
      inputStream = new BufferedReader(new FileReader(outerCode));
      
      /* Copy from macroProcessed to <outputname> */
      while ((line = inputStream.readLine()) != null) {
         outfile.println(line);
      }
   } catch (IOException e) {
        System.out.println("exception happened - here's what I know: ");
        e.printStackTrace();
        printInstruction();
        System.exit(-1);
   }  finally {
        if (inputStream != null) {
            inputStream.close();
        }           
   }
   outfile.println(out.toString());
   outfile.close();
   System.out.println("Fortran output file: "+outputname+" was generated!!");
}
/*
 * 
PHLIN: genSIMD file will use FotranUnParser to create the SIMD Fortran output file.
 *
 */
public void genAltiVec(FCommonTreeNodeStream nodes,SymbolTable symtab, String outputname) throws Exception{
   //String templateFile = "src/StringTemplate/AltiVec.stg";
   ClassLoader cl = this.getClass().getClassLoader();
   InputStream is = cl.getResourceAsStream("StringTemplate/AltiVec.stg");
   InputStreamReader isr = new InputStreamReader(is);
    BufferedReader groupFileR = new BufferedReader(isr);
   //FileReader groupFileR = new FileReader(templateFile);
   StringTemplateGroup templates = new StringTemplateGroup(groupFileR);
   groupFileR.close();
      
   System.out.println("Use the back-end translator!");
/*    FortranAltiVecUnParser unparser = new FortranAltiVecUnParser(nodes,symtab);
    unparser.setTemplateLib(templates); 
    RuleReturnScope unparser_result = unparser.program();
    StringTemplate output = (StringTemplate)unparser_result.getTemplate();
    StringWriter out = new StringWriter();
    StringTemplateWriter templateWriter = new ModAutoIndentWriter(out); 
    output.write(templateWriter);
    if (null == out.toString())       
   {
      System.err.println("output is null! No Fortran output file is created!!");
      return;
   }
    //System.out.println(output.toString());
   PrintWriter outfile = new PrintWriter(new FileWriter(outputname));
   outfile.println(out.toString());
   outfile.close();
   System.out.println("Fortran output file: "+outputname+" was generated!!");
*/   
}
/*
 * 
PHLIN: genC file will use FotranUnParser to create the C output file.
 *
 */
public void genC(FCommonTreeNodeStream nodes,SymbolTable symtab, String outputname) throws Exception{
   //String templateFile = "src/StringTemplate/f2c.stg";
   ClassLoader cl = this.getClass().getClassLoader();
   InputStream is = cl.getResourceAsStream("StringTemplate/f2c.stg");
   InputStreamReader isr = new InputStreamReader(is);
    BufferedReader groupFileR = new BufferedReader(isr);
   //FileReader groupFileR = new FileReader(templateFile);
   StringTemplateGroup templates = new StringTemplateGroup(groupFileR);
   groupFileR.close();
   
   System.out.println("Use the back-end translator!");
/*    CUnParser unparser = new CUnParser(nodes,symtab);
    unparser.setTemplateLib(templates); 
    RuleReturnScope unparser_result = unparser.program();
    StringTemplate output = (StringTemplate)unparser_result.getTemplate();
    if (null == output.toString())       
   {
      System.err.println("output is null! No C output file is created!!");
      return;
   }
    //System.out.println(output.toString());
   PrintWriter outfile = new PrintWriter(new FileWriter(outputname));
   outfile.println(output.toString());
   outfile.close();
   System.out.println("C output file: "+outputname+" was generated!!");
*/   
}
/*
 * 
PHLIN: genSSE file will use FotranUnParser to create the C output file.
 *
 */
public void genSSE(FCommonTreeNodeStream nodes,SymbolTable symtab, String outputname) throws Exception{
   //String templateFile = "src/StringTemplate/SSE.stg";
   ClassLoader cl = this.getClass().getClassLoader();
   InputStream is = cl.getResourceAsStream("StringTemplate/SSE.stg");
   InputStreamReader isr = new InputStreamReader(is);
    BufferedReader groupFileR = new BufferedReader(isr);
   //FileReader groupFileR = new FileReader(templateFile);
   StringTemplateGroup templates = new StringTemplateGroup(groupFileR);
   groupFileR.close();
   
   System.out.println("Use the back-end translator!");
/*    SSEUnParser unparser = new SSEUnParser(nodes,symtab);
    unparser.setTemplateLib(templates); 
    RuleReturnScope unparser_result = unparser.program();
    StringTemplate output = (StringTemplate)unparser_result.getTemplate();
    if (null == output.toString())       
   {
      System.err.println("output is null! No SSE output file is created!!");
      return;
   }
    //System.out.println(output.toString());
   PrintWriter outfile = new PrintWriter(new FileWriter(outputname));
   outfile.println(output.toString());
   outfile.close();
   System.out.println("SSE output file: "+outputname+" was generated!!");
*/   
}
/*
 * PHLIN: deletefile will delete the assigned file.
 * This method is designed to delete the temporary files macroProcessed, outerCode, and computeRegion.
 *
 */
public static boolean deletefile(String fileName) {
    // A File object to represent the filename
    File f = new File(fileName);
    // Make sure the file or directory exists and isn't write protected
    if (!f.exists())
      throw new IllegalArgumentException("Delete: no such file or directory: " + fileName);
    if (!f.canWrite())
      throw new IllegalArgumentException("Delete: write protected: "+ fileName);
    // Attempt to delete it
    boolean success = f.delete();
    if (!success)
      throw new IllegalArgumentException("Delete: deletion failed");
    return success;
}

/*
 * PHLIN: preProcessSourceFile will run compiler preprocessor toe remove the #define in source code.
 * 
 * IMPORTANT: 
 * Translator will look for ifort first, then the GNU compiler to do the preprocessing.
 * 
 */
public static void preProcessSourceFile(String filename) throws Exception{
//   boolean isintel = false;
//   boolean isgfortran = false;
   String[] Inteltest = {"ifort","-v"};
   String[] GCCtest = {"gfortran","-v"};
   String[] commands = {};
//   String[] IntelCommand = {"ifort","-EP",filename};   //this is reserved for the Linux version fortran compiler
//   String[] IntelCommand = {"ifort","/EP",filename};   //This is reserved for the Windows version fortran compiler
   /* 09/07/2012:  
    * ifort -P option which redirects the preprocessed output to a file doesn't omit
    * the #line directives.  The -EP option which omits the #line directives sends
    * the output to stdOut.  We need to read stdoutput from Java runtime exec and 
    * write it out explicitly to macroProcessed. 
    */
   String[] IntelCommand = {"","",""};
   String[] GCCCommand = {"gfortran","-E","-cpp",filename};
   //String mycommand="";
    String s = null;
    String os = "";
    os = System.getProperty("os.name");
    if(os.contains("Windows")){
       System.out.println("OS:"+os);
       IntelCommand[0] = "ifort";
       IntelCommand[1] = "/EP";
       IntelCommand[2] = filename;
    }else{
       IntelCommand[0] = "ifort";
       IntelCommand[1] = "-EP";
       IntelCommand[2] = filename;
//       IntelCommand[3] = ">";
//       IntelCommand[4] = macroProcessed;       
    }
    try{
       Process p = Runtime.getRuntime().exec(Inteltest);
//       isintel = true;
       commands = new String[IntelCommand.length];
       for(int i=0;i<IntelCommand.length;i++){
          commands[i] = IntelCommand[i];
       }
       //mycommand = "ifort -P "+filename+" -o macroProcessed";
    }catch (IOException e) {
//       isintel = false;
        System.err.println("Warning: Intel Fortran isn't available on this machine. Try GNU instead!");
        try{
           Process p = Runtime.getRuntime().exec(GCCtest);
//           isgfortran = true;
           commands = new String[GCCCommand.length];
           for(int i=0;i<GCCCommand.length;i++){
              commands[i] = GCCCommand[i];              
           }
           System.out.println("commands = "+Arrays.toString(commands));
           //mycommand = "gfortran -E -cpp "+filename+" -o macroProcessed";
        }catch (IOException e1) {
//          isgfortran = false;
            System.err.println("Warning:GNU Fortran isn't available on this machine.");
            System.err.println("Translator requires Intel Fortran or GNU Fortran compiler support!!");
            System.err.println("Exit translation!");
            printInstruction();
            System.exit(-1);
        }
        //e.printStackTrace();
    }

    BufferedReader inputStream = null;
    PrintWriter outputStream = null;
    
    //System.out.println("Preprocessor command:"+commands);
    try {           
          Process p = Runtime.getRuntime().exec(commands);
          BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
            BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            // Redirect the output to macroProcessed       
            try {
               FileWriter fstream = new FileWriter(macroProcessed);
               BufferedWriter out = new BufferedWriter(fstream);
                while ((s = stdInput.readLine()) != null) {
                    out.write(s+"\n");
                }
                out.close();
            }  catch (Exception e){
                  System.err.println("Error: "+e.getMessage());
            }
            // read any errors from the attempted command
            while ((s = stdError.readLine()) != null) {
                System.out.println("Here is the standard error of the command (if any):\n");
                System.out.println(s);
            }
            
            //System.exit(0);
    }catch (IOException e) {
            System.out.println("exception happened - here's what I know: ");
            e.printStackTrace();
            printInstruction();
            System.exit(-1);
    }    
    removeLineContinuations();    
}    

public static void removeLineContinuations() throws Exception{
   List<String> fileList = new ArrayList<String>();
   Iterator<String> iterator;
   int listSize, i, lastline;
   String line, linecont;
   
    BufferedReader inputStream = null;
    PrintWriter outputStreamOuter = null;
    PrintWriter outputStreamCompute = null;
    try{
       /*
         if(os.contains("Windows")){        
          System.out.println(filename.replace(filename.substring(filename.length()-2),".i"));
          File f = new File(filename.replace(filename.substring(filename.length()-2),".i"));          
          //   f.renameTo(new File(macroProcessed)); doesn't work       
           moveFile(f,new File(macroProcessed));   
         }
       */

      inputStream = new BufferedReader(new FileReader(macroProcessed));
      outputStreamOuter = new PrintWriter(new FileWriter(outerCode));
      outputStreamCompute = new PrintWriter(new FileWriter(computeRegion));
      String prev, newlines;
      String dir0 = "DIR$", dir1 = "DEC$", dir2 = "PPM$", dir3 = "PPD$", dir4 = "$OMP";
      boolean bparseRegion = false;

      Pattern pCont  = Pattern.compile("^\\s{5}[^0\\s]");
      Pattern pBegin = Pattern.compile("^cPPM\\$\\s+PARSE\\s+BEGIN");
      Pattern pEnd   = Pattern.compile("^cPPM\\$\\s+PARSE\\s+END");
      Matcher m;
      
      while ((line = inputStream.readLine()) != null) {
         m = pBegin.matcher(line);
         if (m.find()) {
            bparseRegion = true;
         }
         if (bparseRegion){
            fileList.add(line);
         } else {
            outputStreamOuter.println(line);
         }
         m = pEnd.matcher(line);
         if (m.find()){
            bparseRegion = false;            
         }

      }
      
      lastline = 0;
      listSize = fileList.size();
      for(i=0; i<listSize; i++) {      
         line = fileList.get(i);
         
         if (line.contentEquals("\r\n") || line.isEmpty()){
            fileList.set(i,"d");
            continue;
         }
               
         /* A directive or a comment */
         if (line.length() > 0 && (line.charAt(0) == 'c' || line.charAt(0) == 'C' || 
                                 line.charAt(0) == '*' || line.charAt(0) == '!' || 
                                 line.charAt(0) == '#')) 
         {            
            if (line.length()>5 && (line.substring(1,5).equalsIgnoreCase(dir2) || line.substring(1,5).equalsIgnoreCase(dir3)
                               || line.substring(1,5).equalsIgnoreCase(dir0) || line.substring(1,5).equalsIgnoreCase(dir1) 
                                   || line.substring(1,5).equalsIgnoreCase(dir4)))
            {
               /* 
                * Don't convert the DEC and OMP directives to lowercase 
                */
               fileList.set(i,line);         
            } 
            else {
                   /* A comment */
                  fileList.set(i,"d");
            }
            continue;
         }   
         
         line = FortrantoLowerCase(line);
         fileList.set(i,line);
         
         m = pCont.matcher(line);
         if (m.find()){
            linecont = line.substring(m.end());
            
            line = fileList.get(lastline) + linecont;
            fileList.set(lastline,line);
            
            fileList.set(i,"d");
         }  else {
            lastline = i;
         }
      }

      iterator = fileList.iterator();
      while (iterator.hasNext()) {
         line = iterator.next();
         if (!line.contentEquals("d")) {
            outputStreamCompute.println(line);
         }
      }
   } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStreamOuter != null) {
                outputStreamOuter.close();
            }
            if (outputStreamCompute != null) {
                outputStreamCompute.close();
            }            
    }
}

public static String FortrantoLowerCase(String input){
   String[] ompstring =
      {"omp_lib",
       "kmp_set_stacksize_s",
       "omp_set_num_threads",
       "omp_get_num_threads",
       "omp_get_thread_num",
       "mpi_init",
       "mpi_comm_size",
       "mpi_comm_rank",
       "mpi_comm_world",
       "mpi_status_size",
       "mpi_barrier",
       "mpi_finalize",
       "mpi_recv",
       "mpi_irecv",
       "mpi_send",
       "mpi_isend",
       "mpi_byte",
       "mpi_real4",
       "mpi_iprobe",
       "mpi_any_source",
       "mpi_any_tag",
       "mpi_wait"};   
    String newstring="", tmpstring;
 /* I am able to handle all the cases of the Fortran string with
  * the following simple pattern. 
  *   Special case 1: The string appears in multiple lines.
  *     Since we remove the line continuation character, and 
  *     concatenate the lines, we must see the beginning and 
  *     end of a Fortran string for any given 'input'.  
  *   Special case 2: ' appears inside the string.   
  *     Fortran allows the ' to appear inside a string.  It 
  *     needs the escape character ' in front of it.  Although
  *     the double ' might semantically appear as end of one  
  *     string and beginning of another if no special patterns
  *     are used, it doesn't matter for this procedure.  Even if
  *     we treat this special case as two string, or more, the
  *     output is still right!
  */     
   Pattern p = Pattern.compile("'[^']+'");
   Matcher m;
   int prevEnd;
    
    m = p.matcher(input);
    prevEnd = 0;
   while (m.find()) {
    /* The substring between the end of the previous pattern and the beginning of the
     * current pattern must be converted to lowercase.   
     */
      tmpstring = input.substring(prevEnd,m.start()).toLowerCase(); // The last character of the substring extracted is  
                                                                    // actually the m.start() character of input from the
                                                                    // m.start()-1 position.  Strings in Java are 0 based.
       for(int i=0;i<ompstring.length;i++){
          tmpstring = tmpstring.replace(ompstring[i],(ompstring[i]).toUpperCase());
       }   
    /* Don't convert the original string constant in the Fortran program to lowercase. */       
      newstring = newstring + tmpstring + input.substring(m.start(),m.end());    // m.end() refers to the pattern end character
                                                                               // position + 1.
      prevEnd = m.end();
   }   
   if(prevEnd <= input.length()){
    /* Convert the remaining portion of the input, if any, to lowercase. */    
      tmpstring = input.substring(prevEnd).toLowerCase();
       for(int i=0;i<ompstring.length;i++){
          tmpstring = tmpstring.replace(ompstring[i],(ompstring[i]).toUpperCase());
       }   
      newstring = newstring + tmpstring;
   }
      
   return newstring;
}

public static void printInstruction(){
   System.out.println("Usage: java -jar LCSE-Translator.jar [options] inputfile");
   System.out.println();
   System.out.println("Options:");
   System.out.println("\t-keep\t\t\tKeep the temporary files.");
   System.out.println("\t-dot\t\t\tGenerate dot graphic file.");
   System.out.println();
   System.out.println("Supported Directives:");
   System.out.println("\tcPPM$ PARSE [BEGIN | END]\tParse the code within this region; leave the rest untouched.");
   System.out.println("\tcPPM$ PIPELINE \t\tIdentifies the loop to update a pencil of briquettes.");
   System.out.println("\tcPPM$ DOUBLEBUFFER <name>\tVariables to be double-buffered and prefetched.");
   System.out.println("\tcPPM$ PREFETCH [BEGIN | END]\tMark the prefetch region.");
   System.out.println("\tcPPM$ COPYBUFFER <integer constant> TIMES\tSpecify the data transfer size for the prefetches.");
   System.out.println("\tcPPM$ DEDOUBLEBUFFER <name>\tRemove double-buffering no longer needed after pipelining.");
   System.out.println("\tcPPM$ ELIMINATE REDUNDANT ITERATIONS\tEliminate redundancy in mini-domain constructions.");
   System.out.println("\tcPPM$ ELIMINATE REDUNDANT SUBSCRIPTEXP <name>\tEliminate the given expression from subscripts.");
   System.out.println("\tcPPM$ LONGITUDINAL LOOP\tComputational loop to be merged and pipelined.");
   System.out.println("\tcPPM$ REPACK LOOP\tLoops which pack the results of computations back into briquettes.");
   System.out.println("\tcPPM$ INLINE\t\tInline the subroutine.");
}
/*
public static void moveFile(File src, File dest) 
{
       InputStream inStream = null;
        OutputStream outStream = null;
 
       try{
           inStream = new FileInputStream(src);
           outStream = new FileOutputStream(dest);
 
           byte[] buffer = new byte[1024];
 
           int length;
           //copy the file content in bytes 
           while ((length = inStream.read(buffer)) > 0){ 
              outStream.write(buffer, 0, length); 
           }
 
           inStream.close();
           outStream.close();
 
           //delete the original file
           src.delete();
 
       }catch(IOException e){
           e.printStackTrace();
       }
}
*/
} //end of class Translator

